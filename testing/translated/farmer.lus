node main(
  choice : subrange [0, 3] of int
) returns (
  wolf : bool;
  goat : bool;
  cabbage : bool;
  farmer : bool
);
var
  solved : bool;
  nothing_eaten : bool;
  wellformed : bool;
  prop : bool;
  boat~0.choice : subrange [0, 3] of int;
  boat~0.object : subrange [0, 3] of int;
  boat~0.farmer : bool;
  boat~0.result : bool;
  boat~1.choice : subrange [0, 3] of int;
  boat~1.object : subrange [0, 3] of int;
  boat~1.farmer : bool;
  boat~1.result : bool;
  boat~2.choice : subrange [0, 3] of int;
  boat~2.object : subrange [0, 3] of int;
  boat~2.farmer : bool;
  boat~2.result : bool;
  swap~0.side : bool;
  swap~0.other : bool;
  historically~0.x : bool;
  historically~0.holds : bool;
  boat~0.swap~0.side : bool;
  boat~0.swap~0.other : bool;
  boat~1.swap~0.side : bool;
  boat~1.swap~0.other : bool;
  boat~2.swap~0.side : bool;
  boat~2.swap~0.other : bool;
let
  wolf = boat~0.result;

  goat = boat~1.result;

  cabbage = boat~2.result;

  farmer = (false -> swap~0.other);

  nothing_eaten = (((wolf = goat) => (farmer = goat)) and ((goat = cabbage) => (farmer = cabbage)));

  wellformed = ((((choice = 1) => (farmer = wolf)) and ((choice = 2) => (farmer = goat))) and ((choice = 3) => (farmer = cabbage)));

  solved = ((((wolf = true) and (goat = true)) and (cabbage = true)) and (farmer = true));

  prop = (not (historically~0.holds and solved));

  boat~0.choice = choice;

  boat~0.object = 1;

  boat~0.farmer = farmer;

  boat~0.result = (false -> (if ((pre boat~0.choice) = boat~0.object) then boat~0.swap~0.other else (pre boat~0.result)));

  boat~1.choice = choice;

  boat~1.object = 2;

  boat~1.farmer = farmer;

  boat~1.result = (false -> (if ((pre boat~1.choice) = boat~1.object) then boat~1.swap~0.other else (pre boat~1.result)));

  boat~2.choice = choice;

  boat~2.object = 3;

  boat~2.farmer = farmer;

  boat~2.result = (false -> (if ((pre boat~2.choice) = boat~2.object) then boat~2.swap~0.other else (pre boat~2.result)));

  swap~0.side = (pre farmer);

  swap~0.other = (if (swap~0.side = false) then true else false);

  historically~0.x = (nothing_eaten and wellformed);

  historically~0.holds = (historically~0.x and (true -> (pre historically~0.holds)));

  boat~0.swap~0.side = (pre boat~0.result);

  boat~0.swap~0.other = (if (boat~0.swap~0.side = false) then true else false);

  boat~1.swap~0.side = (pre boat~1.result);

  boat~1.swap~0.other = (if (boat~1.swap~0.side = false) then true else false);

  boat~2.swap~0.side = (pre boat~2.result);

  boat~2.swap~0.other = (if (boat~2.swap~0.side = false) then true else false);

  --%PROPERTY prop;

tel;